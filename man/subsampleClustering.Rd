% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/featureSubsample.R, R/subsampleClustering.R,
%   R/tempsubsample.R
\name{subsampleClustering}
\alias{subsampleClustering}
\alias{subsampleClustering}
\alias{subsampleClustering}
\title{Cluster subsamples of the data}
\usage{
subsampleClustering(x, k, clusterFunction = "pam", clusterArgs = NULL,
  classifyMethod = c("All", "InSample", "OutOfSample"),
  classifyFunction = NULL, largeDataset = FALSE, resamp.num = 100,
  samp.p = 0.7, ncores = 1, ...)

subsampleClustering(x, k, clusterFunction = "pam", clusterArgs = NULL,
  classifyMethod = c("All", "InSample", "OutOfSample"),
  classifyFunction = NULL, largeDataset = FALSE, resamp.num = 100,
  samp.p = 0.7, ncores = 1, ...)

subsampleClustering(x, k, clusterFunction = "pam", clusterArgs = NULL,
  classifyMethod = c("All", "InSample", "OutOfSample"),
  classifyFunction = NULL, largeDataset = FALSE, resamp.num = 100,
  samp.p = 0.7, ncores = 1, ...)
}
\arguments{
\item{x}{the data on which to run the clustering (samples in columns).}

\item{k}{number of clusters to find for each clustering of a subsample
(passed to clusterFunction).}

\item{clusterFunction}{a function that clusters a \code{p x n} matrix of
data. Can also be given character values 'pam' or 'kmeans' to indicate use
of internal wrapper functions. Must accept arguments 'x' and 'k' (whether
uses them or not). See Details for format of what must return.}

\item{clusterArgs}{a list of parameter arguments to be passed to
clusterFunction.}

\item{classifyMethod}{method for determining which samples should be used in
the co-occurance matrix. "All"= all samples, "OutOfSample"= those not
subsampled, and "InSample"=those in the subsample.  "All" and "OutOfSample"
require that you provide classifyFunction to define how to classify those
samples not in the subsample into a cluster. If "All" is chosen, all
samples will be classified into clusters via the classifyFunctions, not
just those that are out-of-sample. Note if not choose 'All' possible to get
NAs in resulting D matrix (particularly if not enough subsamples taken).}

\item{classifyFunction}{a function which, given the output of clusterFunction
and new data points, will classify the new data points into a cluster.}

\item{resamp.num}{the number of subsamples to draw.}

\item{samp.p}{the proportion of samples to sample for each subsample.}

\item{ncores}{integer giving the number of cores. If ncores>1, mclapply will
be called.}

\item{...}{arguments passed to mclapply (if ncores>1).}

\item{x}{the data on which to run the clustering (samples in columns).}

\item{k}{number of clusters to find for each clustering of a subsample
(passed to clusterFunction).}

\item{clusterFunction}{a function that clusters a \code{p x n} matrix of
data. Can also be given character values 'pam' or 'kmeans' to indicate use
of internal wrapper functions. Must accept arguments 'x' and 'k' (whether
uses them or not). See Details for format of what must return.}

\item{clusterArgs}{a list of parameter arguments to be passed to
clusterFunction.}

\item{resamp.num}{the number of subsamples to draw.}

\item{samp.p}{the proportion of samples to sample for each subsample.}

\item{classifyMethod}{method for determining which samples should be used in
the co-occurance matrix. "All"= all samples, "OutOfSample"= those not
subsampled, and "InSample"=those in the subsample.  "All" and "OutOfSample"
require that you provide classifyFunction to define how to classify those
samples not in the subsample into a cluster. If "All" is chosen, all
samples will be classified into clusters via the classifyFunctions, not
just those that are out-of-sample. Note if not choose 'All' possible to get
NAs in resulting D matrix (particularly if not enough subsamples taken).}

\item{classifyFunction}{a function which, given the output of clusterFunction
and new data points, will classify the new data points into a cluster.}

\item{ncores}{integer giving the number of cores. If ncores>1, mclapply will
be called.}

\item{...}{arguments passed to mclapply (if ncores>1).}

\item{x}{the data on which to run the clustering (samples in columns).}

\item{k}{number of clusters to find for each clustering of a subsample
(passed to clusterFunction).}

\item{clusterFunction}{a function that clusters a \code{p x n} matrix of
data. Can also be given character values 'pam' or 'kmeans' to indicate use
of internal wrapper functions. Must accept arguments 'x' and 'k' (whether
uses them or not). See Details for format of what must return.}

\item{clusterArgs}{a list of parameter arguments to be passed to
clusterFunction.}

\item{resamp.num}{the number of subsamples to draw.}

\item{samp.p}{the proportion of samples to sample for each subsample.}

\item{classifyMethod}{method for determining which samples should be used in
the co-occurance matrix. "All"= all samples, "OutOfSample"= those not
subsampled, and "InSample"=those in the subsample.  "All" and "OutOfSample"
require that you provide classifyFunction to define how to classify those
samples not in the subsample into a cluster. If "All" is chosen, all
samples will be classified into clusters via the classifyFunctions, not
just those that are out-of-sample. Note if not choose 'All' possible to get
NAs in resulting D matrix (particularly if not enough subsamples taken).}

\item{classifyFunction}{a function which, given the output of clusterFunction
and new data points, will classify the new data points into a cluster.}

\item{ncores}{integer giving the number of cores. If ncores>1, mclapply will
be called.}

\item{...}{arguments passed to mclapply (if ncores>1).}
}
\value{
A \code{n x n} matrix of co-occurances.

A \code{n x n} matrix of co-occurances.

A \code{n x n} matrix of co-occurances.
}
\description{
Given a data matrix, this function will subsample the rows
(samples), cluster the subsamples, and return a \code{n x n} matrix with the
probability of co-occurance.

Given a data matrix, this function will subsample the rows
(samples), cluster the subsamples, and return a \code{n x n} matrix with the
probability of co-occurance.

Given a data matrix, this function will subsample the rows
(samples), cluster the subsamples, and return a \code{n x n} matrix with the
probability of co-occurance.
}
\details{
The \code{clusterFunction} must be a function that takes as an
  argument 'x' which is a \code{p x n} matrix  of data and integer 'k'. It
  minimally must return a list with element named 'clustering' giving the
  vector of cluster ids. To be incorporated with the larger hierarchy, it
  should be list with elements of a partition object, just as is returned by
  \code{\link[cluster]{pam}}. Generally, the user will need to write a
  wrapper function to do this. In the case of pam or kmeans, the user can
  identify clusterFunction as "pam" or "kmeans", and the package functions
  will use internally written wrappers for the clusterFunction and
  classifyFunction arguments. Additional arguments should be supplied via
  clusterArgs.

The classifyFunction should take as an object a data matrix 'x' with
  samples on the columns, and the output of the clusterFunction. Note that the
  function should assume that the input 'x' is not the same samples that were
  input to the clusterFunction (but can assume that it is the same number of
  features/columns).

The \code{clusterFunction} must be a function that takes as an
  argument 'x' which is a \code{p x n} matrix  of data and integer 'k'. It
  minimally must return a list with element named 'clustering' giving the
  vector of cluster ids. To be incorporated with the larger hierarchy, it
  should be list with elements of a partition object, just as is returned by
  \code{\link[cluster]{pam}}. Generally, the user will need to write a
  wrapper function to do this. In the case of pam or kmeans, the user can
  identify clusterFunction as "pam" or "kmeans", and the package functions
  will use internally written wrappers for the clusterFunction and
  classifyFunction arguments. Additional arguments should be supplied via
  clusterArgs.

The classifyFunction should take as an object a data matrix 'x' with
  samples on the columns, and the output of the clusterFunction. Note that the
  function should assume that the input 'x' is not the same samples that were
  input to the clusterFunction (but can assume that it is the same number of
  features/columns).

The \code{clusterFunction} must be a function that takes as an
  argument 'x' which is a \code{p x n} matrix  of data and integer 'k'. It
  minimally must return a list with element named 'clustering' giving the
  vector of cluster ids. To be incorporated with the larger hierarchy, it
  should be list with elements of a partition object, just as is returned by
  \code{\link[cluster]{pam}}. Generally, the user will need to write a
  wrapper function to do this. In the case of pam or kmeans, the user can
  identify clusterFunction as "pam" or "kmeans", and the package functions
  will use internally written wrappers for the clusterFunction and
  classifyFunction arguments. Additional arguments should be supplied via
  clusterArgs.

The classifyFunction should take as an object a data matrix 'x' with
  samples on the columns, and the output of the clusterFunction. Note that the
  function should assume that the input 'x' is not the same samples that were
  input to the clusterFunction (but can assume that it is the same number of
  features/columns).
}
\examples{
data(simData)

subD <- subsampleClustering(t(simData), k=3, clusterFunction="kmeans",
clusterArgs=list(nstart=10), resamp.n=100, samp.p=0.7)

heatmap(subD)
data(simData)

subD <- subsampleClustering(t(simData), k=3, clusterFunction="kmeans",
clusterArgs=list(nstart=10), resamp.n=100, samp.p=0.7)

heatmap(subD)
data(simData)

subD <- subsampleClustering(t(simData), k=3, clusterFunction="kmeans",
clusterArgs=list(nstart=10), resamp.n=100, samp.p=0.7)

heatmap(subD)
}
