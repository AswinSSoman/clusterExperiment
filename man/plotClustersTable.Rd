% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plotClustersTable.R
\docType{methods}
\name{plotClustersTable}
\alias{plotClustersTable}
\alias{plotClustersTable,ClusterExperiment-method}
\alias{plotClustersTable,table-method}
\alias{tableClusters,ClusterExperiment,character-method}
\alias{tableClusters}
\alias{tableClusters,ClusterExperiment,missing-method}
\alias{tableClusters,ClusterExperiment,numeric-method}
\alias{bubblePlot,table,table-method}
\title{Plot heatmap of cross-tabs of 2 clusterings}
\usage{
\S4method{plotClustersTable}{ClusterExperiment}(object, whichClusters,
  ignoreUnassigned = FALSE, margin = NA, ...)

\S4method{plotClustersTable}{table}(object, clusterLegend = NULL,
  cluster = FALSE, plotType = c("heatmap", "bubble"), sizeTable = object,
  ...)

\S4method{tableClusters}{ClusterExperiment,character}(object, whichClusters,
  ...)

\S4method{tableClusters}{ClusterExperiment,missing}(object, whichClusters, ...)

\S4method{tableClusters}{ClusterExperiment,numeric}(object, whichClusters,
  useNames = TRUE, tableMethod = c("intersect", "union"), ...)

\S4method{bubblePlot}{table,table}(propTable, sizeTable, gridColor = rgb(0, 0,
  0, 0.05), maxCex = 8, cexFactor, ylab, xlab, legend = TRUE, las = 2,
  colorScale = RColorBrewer::brewer.pal(11, "Spectral")[-6])
}
\arguments{
\item{object}{ClusterExperiment object (or matrix with table result)}

\item{whichClusters}{argument that can be either numeric or character value
indicating the clusters to be used. If numeric, gives the indices of the
\code{clusterMatrix} to return; this can also be used to defined an
ordering for the clusterings (as relevant). \code{whichClusters} can be a
character value identifying the \code{clusterTypes} to be used, or if not
matching \code{clusterTypes} then \code{clusterLabels}; alternatively
\code{whichClusters} can be either 'all' or 'workflow' or 'primary' to
indicate choosing all clusterings or choosing all 
\code{\link{workflowClusters}} clusterings or choosing the 'primary'
clustering, respectively. If missing, the entire matrix of all clusterings
is returned.}

\item{ignoreUnassigned}{logical as to whether to ignore unassigned clusters
in the plotting. This means they will also be ignored in the calculations
of the proportions (if \code{margin} not NA).}

\item{margin}{if NA, the counts from \code{tableClusters} will be plotted.
Otherwise, \code{\link[base]{prop.table}} will be called and the argument
\code{margin} will be passed to \code{prop.table} to determine whether
proportions should be calculated. If '1', then the proportions in the rows
sum to 1, if '2' the proportions in the columns sum to 1. If 'NULL' then
the proportion across the entire matrix will sum to 1. For a symmetric
version, you can set \code{margin=0}, and the entry displayed in each cell
will be the proportion equal to the size of the intersection over the size
of the union of the clusters (a Jaccard similarity between the clusters),
in which case each entry is a proportion but no combination of the entries 
sum to 1.}

\item{...}{arguments passed on to \code{plotHeatmap} or \code{bubblePlot} 
depending on choice of \code{plotType}}

\item{clusterLegend}{list in \code{clusterLegend} format that gives colors for the
clusters tabulated.}

\item{cluster}{logical, whether to cluster the rows and columns of the table. Passed
to arguments \code{clusterFeatures} AND \code{clusterSamples} of \code{plotHeatmap}.}

\item{plotType}{type of plot. If "heatmap", then a heatmap will be created of
the values of the contingency table of the two clusters (calculated as
determined by the argument "margin") using \code{\link{plotHeatmap}}. If
"bubble", then a plot will be created using \code{bubblePlot}, which will
create circles for each cell of the contingencey table whose size
corresponds to the number of samples shared and the color based on the
value of the proportion (as chosen by the argument \code{margin}).}

\item{sizeTable}{table of sizes}

\item{useNames}{for \code{tableClusters}, whether the output should be tabled
with names (\code{useNames=TRUE}) or ids (\code{useNames=FALSE})}

\item{tableMethod}{the type of table calculation to perform. "intersect" refers to the standard contingency table (\code{\link[base]{table}}), where each entry of the resulting table is the number of objects in both clusters. "union" instead gives for each entry the number of objects that are in the union of both clusters.}

\item{propTable}{table of proportions}

\item{gridColor}{color for grid lines}

\item{maxCex}{largest value of cex for any point (others will scale
proportionally smaller).}

\item{cexFactor}{factor to multiple by to get values of circles. If missing,
finds value automatically, namely by using the maxCex value default.
Overrides value of maxCex.}

\item{ylab}{label for y-axis. If missing, uses the name for rows in
sizeTable. If set to \code{NULL} no y-axis label will be plotted.}

\item{xlab}{label for x-axis. If missing, uses the name for columns in 
sizeTable. If set to \code{NULL} no y-axis label will be plotted.}

\item{legend}{whether to draw legend along top}

\item{las}{the value for the las value in the call to \code{\link{axis}} in
labeling the clusters in the bubble plot. Determines whether parallel or
perpindicular labels to the axis (see \code{\link{par}}).}

\item{colorScale}{the color scale for the values of the proportion table}
}
\description{
Plot heatmap of cross-tabulations of two clusterings
}
\details{
For \code{plotClustersTable} \code{whichClusters}
  should define 2 clusters, for \code{tableClusters} can indicate arbitrary
  number.

Note that the cluster labels in \code{plotClustersTable} and 
\code{tableClusters} are converted to "proper" R names via \code{make.names}. This is 
because \code{tableClusters} calls the R function \code{table}, which makes this 
conversion

\code{bubblePlot} is mainly used internally by
  \code{plotClustersTable} but is made public for users who want more control
  and to allow documentation of the arguments. \code{bubblePlot} plots a
  circle for each intersection of two clusters, where the color of the circle
  is based on the value in \code{propTable} and the size of the circle is
  based on the value in \code{sizeTable}. The size is determined by setting
  the \code{cex} value of the point as
  $sqrt(sizeTable[i,j])/sqrt(max(sizeTable))*cexFactor$.
}
\examples{
#clustering using pam: try using different dimensions of pca and different k
data(simData)

cl <- clusterMany(simData, nReducedDims=c(5, 10, 50), reducedDim="PCA",
clusterFunction="pam", ks=2:4, findBestK=c(TRUE,FALSE),
removeSil=c(TRUE,FALSE))
#give arbitrary names to clusters for demonstration
cl<-renameClusters(cl,value=letters[1:nClusters(cl)[1]],whichCluster=1)
tableClusters(cl,whichClusters=1:2)
#heatmap of the counts in each entry of table:
plotClustersTable(cl,whichClusters=1:2, ignoreUnassigned=TRUE)
}
\seealso{
\code{\link[base]{prop.table}}

\code{\link{plotHeatmap}}

\code{\link[base]{table}}
}
