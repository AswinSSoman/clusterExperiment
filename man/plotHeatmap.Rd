% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plotHeatmap.R
\docType{methods}
\name{plotHeatmap,SummarizedExperiment-method}
\alias{plotHeatmap,SummarizedExperiment-method}
\alias{plotHeatmap}
\alias{plotHeatmap,ClusterExperiment-method}
\alias{plotHeatmap,data.frame-method}
\alias{plotHeatmap,ExpressionSet-method}
\alias{plotHeatmap,matrix-method}
\alias{plotCoClustering,ClusterExperiment-method}
\alias{plotCoClustering}
\title{Heatmap for showing clustering results and more}
\usage{
\S4method{plotHeatmap}{SummarizedExperiment}(data, isCount = FALSE,
  transFun = NULL, ...)

\S4method{plotHeatmap}{ClusterExperiment}(data,
  clusterSamplesData = c("dendrogramValue", "hclust", "orderSamplesValue",
  "primaryCluster"), clusterFeaturesData = c("var", "all", "PCA"),
  nFeatures = NULL, visualizeData = c("transformed", "centeredAndScaled",
  "original"), whichClusters = c("primary", "workflow", "all", "none"),
  sampleData = NULL, clusterFeatures = TRUE, nBlankLines = 2, colorScale,
  ...)

\S4method{plotHeatmap}{data.frame}(data, ...)

\S4method{plotHeatmap}{ExpressionSet}(data, ...)

\S4method{plotHeatmap}{matrix}(data, sampleData = NULL,
  clusterSamplesData = NULL, clusterFeaturesData = NULL,
  whSampleDataCont = NULL, clusterSamples = TRUE, showSampleNames = FALSE,
  clusterFeatures = TRUE, showFeatureNames = FALSE, colorScale = seqPal5,
  clusterLegend = NULL, alignSampleData = FALSE,
  unassignedColor = "white", missingColor = "grey", breaks = NA,
  isSymmetric = FALSE, overRideClusterLimit = FALSE, ...)

\S4method{plotCoClustering}{ClusterExperiment}(data,
  invert = ifelse(!is.null(data@coClustering) && all(diag(data@coClustering)
  == 0), TRUE, FALSE), ...)
}
\arguments{
\item{data}{data to use to determine the heatmap. Can be a matrix,
\code{\link{ClusterExperiment}} or
\code{\link[SummarizedExperiment]{SummarizedExperiment}} object. The
interpretation of parameters depends on the type of the input to \code{data}.}

\item{isCount}{logical. Whether the data are in counts, in which case the 
default \code{transFun} argument is set as log2(x+1). This is simply a 
convenience to the user, and can be overridden by giving an explicit 
function to \code{transFun}.}

\item{transFun}{function A function to use to transform the input data matrix
before clustering.}

\item{...}{for signature \code{matrix}, arguments passed to \code{aheatmap}. 
For the other signatures, passed to the method for signature \code{matrix}.
Not all arguments can be passed to \code{aheatmap} effectively, see details.}

\item{clusterSamplesData}{If \code{data} is a matrix,
\code{clusterSamplesData} is either a matrix that will be used by
\code{hclust} to define the hiearchical clustering of samples (e.g.
normalized data) or a pre-existing dendrogram that clusters the samples. If
\code{data} is a \code{ClusterExperiment} object, \code{clusterSamplesData}
should be either character or integers or logical which indicates how (and 
whether) the samples should be clustered (or gives indices of the order for
the samples). See details.}

\item{clusterFeaturesData}{If \code{data} is a matrix, either a matrix that
will be used in \code{hclust} to define the hiearchical clustering of
features (e.g. normalized data) or a pre-existing dendrogram that clusters
the features. If \code{data} is a \code{ClusterExperiment} object, the
input should be either character or integers indicating which features
should be used (see details).}

\item{nFeatures}{integer indicating how many features should be used (if
\code{clusterFeaturesData} is 'var' or 'PCA').}

\item{visualizeData}{either a character string, indicating what form of the 
data should be used for visualizing the data (i.e. for making the 
color-scale), or a data.frame/matrix with same number of samples as 
\code{assay(data)}. If a new data.frame/matrix, any character arguments to
clusterFeaturesData will be ignored.}

\item{whichClusters}{character string, or vector of characters or integers,
indicating what clusters should be visualized with the heatmap.}

\item{sampleData}{If input to \code{data} is either a \code{\link{ClusterExperiment}} or
\code{SummarizedExperiment} object, then \code{sampleData} must index the
sampleData stored as a \code{DataFrame} in \code{colData} slot of the
object. Whether that data is continuous or not will be determined by the
properties of \code{colData} (no user input is needed). If input to \code{data} is matrix,
\code{sampleData} is a matrix of additional data on the samples to show
above heatmap. In this case, unless indicated by \code{whSampleDataCont},
\code{sampleData} will be converted into factors, even if numeric. ``-1''
indicates the sample was not assigned to a cluster and gets color
`unassignedColor' and ``-2`` gets the color 'missingColor'.}

\item{clusterFeatures}{Logical as to whether to do hiearchical clustering of
features (if FALSE, any input to clusterFeaturesData is ignored).}

\item{nBlankLines}{Only applicable if input is \code{ClusterExperiment} object. Indicates the number of lines to put between groups of features if \code{clusterFeaturesData} gives groups of genes (see details and \code{\link{makeBlankData}}).}

\item{colorScale}{palette of colors for the color scale of the heatmap.}

\item{whSampleDataCont}{Which of the \code{sampleData} columns are continuous
and should not be converted to counts. \code{NULL} indicates no additional
\code{sampleData}. Only used if \code{data} input is matrix.}

\item{clusterSamples}{Logical as to whether to do hierarchical clustering of
cells (if FALSE, any input to clusterSamplesData is ignored).}

\item{showSampleNames}{Logical as to whether show sample names.}

\item{showFeatureNames}{Logical as to whether show feature names.}

\item{clusterLegend}{Assignment of colors to the clusters. If \code{NULL},
\code{sampleData} columns will be assigned colors internally.
\code{clusterLegend} should be list of length equal to
\code{ncol(sampleData)} with names equal to the colnames of
\code{sampleData}. Each element of the list should be a either the format
requested by \code{\link[NMF]{aheatmap}} (a vector of colors with names
corresponding to the levels of the column of \code{sampleData}), or should
be format of \code{ClusterExperiment}.}

\item{alignSampleData}{Logical as to whether should align the colors of the
\code{sampleData} (only if \code{clusterLegend} not given and
\code{sampleData} is not \code{NULL}).}

\item{unassignedColor}{color assigned to cluster values of '-1'
("unassigned").}

\item{missingColor}{color assigned to cluster values of '-2' ("missing").}

\item{breaks}{Either a vector of breaks (should be equal to length 52), or a
number between 0 and 1, indicating that the breaks should be equally spaced
(based on the range in the data) upto the `breaks' quantile, see
\code{\link{setBreaks}}}

\item{isSymmetric}{logical. if TRUE indicates that the input matrix is
symmetric. Useful when plotting a co-clustering matrix or other sample by
sample matrices (e.g., correlation).}

\item{overRideClusterLimit}{logical. Whether to override the internal limit 
that only allows 10 clusterings/annotations. If overridden, may result in 
incomprehensible errors from \code{aheatmap}. Only override this if you have a
very large plotting device and want to see if \code{aheatmap} can render it.}

\item{invert}{logical determining whether the coClustering matrix should be 
inverted to be 1-coClustering for plotting. By default, if the diagonal 
elements are all zero, invert=TRUE, and otherwise invert=FALSE. If
coClustering matrix is not a 0-1 matrix (e.g. if equal to a distance matrix
output from \code{\link{clusterSingle}}, then the user should manually set
this parameter to FALSE.)}
}
\value{
Returns (invisibly) a list with elements
\itemize{
\item{\code{aheatmapOut}}{ The output from the final call of
\code{\link[NMF]{aheatmap}}.}
\item{\code{sampleData}}{ the annotation data.frame given to the argument
\code{annCol} in \code{aheatmap}.}
\item{\code{clusterLegend}}{ the annotation colors given to the argument
\code{annColors} \code{aheatmap}.}
\item{\code{breaks}}{ The breaks used for \code{aheatmap}, after adjusting
for quantile.}
}
}
\description{
Make heatmap with color scale from one matrix and hiearchical clustering of
samples/features from another. Also built in functionality for showing the
clusterings with the heatmap. Builds on \code{\link[NMF]{aheatmap}} function
of \code{NMF} package.
}
\details{
The plotHeatmap function calls \code{\link[NMF]{aheatmap}} to draw
  the heatmap. The main points of \code{plotHeatmap} are to 1) allow for
  different matrix inputs, separating out the color scale visualization and
  the clustering of the samples/features. 2) to visualize the clusters and
  meta data with the heatmap. The intended use case is to allow the user to
  visualize the original count scale of the data (on the log-scale), but
  create the hierarchical clustering on another, more appropriate dataset for
  clustering, such as normalized data. Similarly, some of the palettes in the
  package were developed assuming that the visualization might be on
  unscaled/uncentered data, rather than the residual from the mean of the
  gene, and thus palettes need to take on a greater range of relevant values
  so as to show meaningful comparisons with genes on very different scales.

If \code{data} is a \code{ClusterExperiment} object,
  \code{visualizeData} indicates what kind of transformation should be done
  to \code{assay(data)} for calculating the color scale. The features will be
  clustered based on these data as well. A different data.frame or matrix can
  be given for the visualization. For example, if the
  \code{ClusterExperiment} object contains normalized data, but the user
  wishes that the color scale be based on the log-counts for easier
  interpretation, \code{visualizeData} could be set to be the
  \code{log2(counts + 1)}.

If \code{data} is a \code{ClusterExperiment} object, 
  \code{clusterSamplesData} can be used to indicate the type of clustering 
  for the samples. If equal to `dendrogramValue` the dendrogram stored in 
  \code{data} will be used; if dendrogram is missing, a new one will be
  created based on the \code{primaryCluster} of data using
  \code{\link{makeDendrogram}}, assuming no errors are created (if errors are
  created, then \code{clusterSamplesData} will be set to "primaryCluster").
  If \code{clusterSamplesData} is equal to "hclust", then standard 
  hierachical clustering of the transformed data will be used. If
  \code{clusterSamplesData} is equal to 'orderSamplesValue' no clustering of
  the samples will be done, and instead the samples will be ordered as in the
  slot \code{orderSamples} of \code{data}. If \code{clusterSamplesData} is
  equal to 'primaryCluster', again no clustering will be done, and instead
  the samples will be ordered based on grouping the samples to match the
  primaryCluster of \code{data}; however, if the primaryCluster of
  \code{data} is only one cluster or consists soley of -1/-2 values,
  \code{clusterSamplesData} will be set to "hclust". If
  \code{clusterSamplesData}  is not a character value, 
  \code{clusterSamplesData} can be a integer valued vector giving the order
  of the samples.

If \code{data} is a matrix, then \code{sampleData} is a data.frame
  of annotation data to be plotted above the heatmap and
  \code{whSampleDataCont} gives the index of the column(s) of this dataset
  that should be consider continuous. Otherwise the annotation data for
  \code{sampleData} will be forced into a factor (which will be nonsensical
  for continous data). If \code{data} is a \code{ClusterExperiment} object,
  \code{sampleData} should refer to a index or column name of the
  \code{colData} slot of \code{data}. In this case \code{sampleData} will be
  added to any choices of clusterings chosen by the \code{whichClusters}
  argument (if any). If both clusterings and sample data are chosen, the
  clusterings will be shown closest to data (i.e. on bottom).

If \code{data} is a \code{ClusterExperiment} object,
  \code{clusterFeaturesData} is not a dataset, but instead indicates which
  features should be shown in the heatmap. "var" selects the
  \code{nFeatures} most variable genes (based on
  \code{transformation(assay(data))}); "PCA" results in a heatmap of the top
  \code{nFeatures} PCAs of the \code{transformation(assay(data))}.
  clusterFeaturesData can also be a vector of characters or integers,
  indicating the rownames or indices respectively of \code{assay(data)} that
  should be shown. For all of these options, the features are clustered based
  on the \code{visualizeData} data. Finally, in the \code{ClusterExperiment}
  version of \code{plotHeatmap}, \code{clusterFeaturesData} can be a list of
  indices or rownames, indicating that the features should be grouped
  according to the elements of the list, with blank (white) space between
  them (see \code{\link{makeBlankData}} for more details). In this case, no
  clustering is done of the features.

If \code{breaks} is a numeric value between 0 and 1, then
  \code{breaks} is assumed to indicate the upper quantile (on the log scale)
  at which the heatmap color scale should stop. For example, if
  \code{breaks=0.9}, then the breaks will evenly spaced up until the 0.9
  upper quantile of \code{data}, and then all values after the
  0.9 quantile will be absorbed by the upper-most color bin. This can help to
  reduce the visual impact of a few highly expressed genes (features).

Note that plotHeatmap calls \code{\link[NMF]{aheatmap}} under the 
  hood. This allows you to plot multiple heatmaps via 
  \code{par(mfrow=c(2,2))}, etc. However, the dendrograms do not resize if 
  you change the size of your plot window in an interactive session of R 
  (this might be a problem for RStudio if you want to pop it out into a large
  window...). Also, plotting to a pdf adds a blank page; see help pages of
  \code{\link[NMF]{aheatmap}} for how to turn this off.

If you have a factor with many levels, it is important to note that
  \code{\link[NMF]{aheatmap}} does not recycle colors across factors in the
  \code{sampleData}, and in fact runs out of colors and the remaining levels
  get the color white. Thus if you have many factors or many levels in those
  factors, you should set their colors via \code{clusterLegend}.

Many arguments can be passed on to \code{aheatmap}, however, some are set 
  internally by \code{plotHeatmap.} In particular, setting the values of 
  \code{Rowv} or \code{Colv} will cause errors. \code{color} in 
  \code{aheatmap} is replaced by \code{colorScale} in \code{plotHeatmap.} The
  \code{annCol} to give annotation to the samples is replaced by the
  \code{sampleData}; moreover, the \code{annColors} option in \code{aheatmap}
  will also be set internally to give more vibrant colors than the default in
  \code{aheatmap} (for \code{ClusterExperiment} objects, these values can
  also be set in the \code{clusterLegend} slot ). Other options should be
  passed on to \code{aheatmap}, though they have not been all tested.

\code{plotCoClustering} is a convenience function to plot the heatmap
of the co-clustering matrix stored in the \code{coClustering} slot of a
\code{ClusterExperiment} object.
}
\examples{
data(simData)

cl <- rep(1:3,each=100)
cl2 <- cl
changeAssign <- sample(1:length(cl), 80)
cl2[changeAssign] <- sample(cl[changeAssign])
ce <- clusterExperiment(simCount, cl2, transformation=function(x){log2(x+1)})

#simple, minimal, example. Show counts, but cluster on underlying means
plotHeatmap(ce)

#assign cluster colors
colors <- bigPalette[20:23]
names(colors) <- 1:3
plotHeatmap(data=simCount, clusterSamplesData=simData,
sampleData=data.frame(cl), clusterLegend=list(colors))

#show two different clusters
anno <- data.frame(cluster1=cl, cluster2=cl2)
out <- plotHeatmap(simData, sampleData=anno)

#return the values to see format for giving colors to the annotations
out$clusterLegend

#assign colors to the clusters based on plotClusters algorithm
plotHeatmap(simData, sampleData=anno, alignSampleData=TRUE)

#assign colors manually
annoColors <- list(cluster1=c("black", "red", "green"),
cluster2=c("blue","purple","yellow"))

plotHeatmap(simData, sampleData=anno, clusterLegend=annoColors)

#give a continuous valued -- need to indicate columns
anno2 <- cbind(anno, Cont=c(rnorm(100, 0), rnorm(100, 2), rnorm(100, 3)))
plotHeatmap(simData, sampleData=anno2, whSampleDataCont=3)

#compare changing breaks quantile on visual effect
\dontrun{
par(mfrow=c(2,2))
plotHeatmap(simData, colorScale=seqPal1, breaks=1, main="Full length")
plotHeatmap(simData,colorScale=seqPal1, breaks=.99, main="0.99 Quantile Upper
Limit")
plotHeatmap(simData,colorScale=seqPal1, breaks=.95, main="0.95 Quantile Upper
Limit")
plotHeatmap(simData, colorScale=seqPal1, breaks=.90, main="0.90 Quantile
Upper Limit")
}

}
\seealso{
\code{\link[NMF]{aheatmap}}, \code{\link{makeBlankData}}
}
\author{
Elizabeth Purdom
}
