% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plotHeatmap.R
\docType{methods}
\name{plotHeatmap,SummarizedExperiment-method}
\alias{plotCoClustering}
\alias{plotCoClustering,ClusterExperiment-method}
\alias{plotHeatmap}
\alias{plotHeatmap,ClusterExperiment-method}
\alias{plotHeatmap,SummarizedExperiment-method}
\alias{plotHeatmap,matrix-method}
\title{Heatmap for showing clustering results and more}
\usage{
\S4method{plotHeatmap}{SummarizedExperiment}(data, isCount = FALSE,
  transFun = NULL, ...)

\S4method{plotHeatmap}{ClusterExperiment}(data,
  clusterSamplesData = c("hclust", "dendrogramValue", "orderSamplesValue",
  "primaryCluster"), clusterFeaturesData = c("var", "all", "PCA"),
  nFeatures = NULL, visualizeData = c("transformed", "centeredAndScaled",
  "original"), whichClusters = c("primary", "workflow", "all", "none"),
  sampleData = NULL, clusterFeatures = TRUE, colorScale, ...)

\S4method{plotHeatmap}{matrix}(data, sampleData = NULL,
  clusterSamplesData = data, clusterFeaturesData = data,
  whSampleDataCont = NULL, clusterSamples = TRUE, showSampleNames = FALSE,
  clusterFeatures = TRUE, showFeatureNames = FALSE, colorScale = seqPal5,
  clusterLegend = NULL, alignSampleData = FALSE,
  unassignedColor = "white", missingColor = "grey", breaks = NA,
  isSymmetric = FALSE, overRideClusterLimit = FALSE, ...)

\S4method{plotCoClustering}{ClusterExperiment}(data, ...)
}
\arguments{
\item{data}{data to use to determine the heatmap. Can be a matrix,
\code{\link{ClusterExperiment}} or
\code{\link[SummarizedExperiment]{SummarizedExperiment}} object. The
interpretation of parameters depends on the type of the input.}

\item{isCount}{logical. Whether the data are in counts, in which case the
default \code{transFun} argument is set as log2(x+1). This is simply a
convenience to the user, and can be overridden by giving an explicit
function to \code{transFun}.}

\item{transFun}{function A function to use to transform the input data matrix
before clustering.}

\item{...}{for signature \code{matrix}, arguments passed to \code{aheatmap}.
For the other signatures, passed to the method for signature \code{matrix}.}

\item{clusterSamplesData}{If \code{data} is a matrix, either a matrix that
will be used to in \code{hclust} to define the hiearchical clustering of
samples (e.g. normalized data) or a pre-existing dendrogram that clusters
the samples. If \code{data} is a \code{ClusterExperiment} object, the input
should be either character or integers. Indicates how (and whether) the
samples should be clustered (or gives indices of the order for the
samples). See details.}

\item{clusterFeaturesData}{If \code{data} is a matrix, either a matrix that
will be used in \code{hclust} to define the hiearchical clustering of
features (e.g. normalized data) or a pre-existing dendrogram that clusters
the features. If \code{data} is a \code{ClusterExperiment} object, the
input should be either character or integers indicating which features
should be used (see details).}

\item{nFeatures}{integer indicating how many features should be used (if
\code{clusterFeaturesData} is 'var' or 'PCA').}

\item{visualizeData}{either a character string, indicating what form of the
data should be used for visualizing the data (i.e. for making the
color-scale), or a data.frame/matrix with same dimensions of
\code{assay(data)}.}

\item{whichClusters}{character string, or vector of characters or integers,
indicating what clusters should be visualized with the heatmap.}

\item{sampleData}{If input is either a \code{\link{ClusterExperiment}} or
\code{SummarizedExperiment} object, then \code{sampleData} must index the
sampleData stored as a \code{DataFrame} in \code{colData} slot of the
object. Whether that data is continuous or not will be determined by the
properties of \code{colData} (no user input is needed). If input is matrix,
\code{sampleData} is a matrix of additional data on the samples to show
above heatmap. Unless indicated by \code{whSampleDataCont},
\code{sampleData} will be converted into factors, even if numeric. ``-1''
indicates the sample was not assigned to a cluster and gets color
`unassignedColor' and ``-2`` gets the color 'missingColor'.}

\item{clusterFeatures}{Logical as to whether to do hiearchical clustering of
features (if FALSE, any input to clusterFeaturesData is ignored).}

\item{colorScale}{palette of colors for the color scale of the heatmap.}

\item{whSampleDataCont}{Which of the \code{sampleData} columns are continuous
and should not be converted to counts. \code{NULL} indicates no additional
\code{sampleData}.}

\item{clusterSamples}{Logical as to whether to do hierarchical clustering of
cells (if FALSE, any input to clusterSamplesData is ignored).}

\item{showSampleNames}{Logical as to whether show sample names.}

\item{showFeatureNames}{Logical as to whether show feature names.}

\item{clusterLegend}{Assignment of colors to the clusters. If \code{NULL},
\code{sampleData} columns will be assigned colors internally.
\code{clusterLegend} should be list of length equal to
\code{ncol(sampleData)} with names equal to the colnames of
\code{sampleData}. Each element of the list should be a either the format
requested by \code{\link[NMF]{aheatmap}} (a vector of colors with names
corresponding to the levels of the column of \code{sampleData}), or should
be format of \code{ClusterExperiment}.}

\item{alignSampleData}{Logical as to whether should align the colors of the
\code{sampleData} (only if \code{clusterLegend} not given and
\code{sampleData} is not \code{NULL}).}

\item{unassignedColor}{color assigned to cluster values of '-1'
("unassigned").}

\item{missingColor}{color assigned to cluster values of '-2' ("missing").}

\item{breaks}{Either a vector of breaks (should be equal to length 52), or a
number between 0 and 1, indicating that the breaks should be equally spaced
(based on the range in the data) upto the `breaks' quantile, see
\code{\link{setBreaks}}}

\item{isSymmetric}{logical. if TRUE indicates that the input matrix is
symmetric. Useful when plotting a co-clustering matrix or other sample by
sample matrices (e.g., correlation).}

\item{overRideClusterLimit}{logical. Whether to override the internal limit 
that only allows 10 clusterings/annotations. If overridden, may result in 
incomprehensible errors from aheatmap. Only override this if you have a
very large plotting device and want to see if aheatmap can render it.}
}
\value{
Returns (invisibly) a list with elements
\itemize{
\item{\code{aheatmapOut}}{ The output from the final call of
\code{\link[NMF]{aheatmap}}.}
\item{\code{sampleData}}{ the annotation data.frame given to the argument
\code{annCol} in \code{aheatmap}.}
\item{\code{clusterLegend}}{ the annotation colors given to the argument
\code{annColors} \code{aheatmap}.}
\item{\code{breaks}}{ The breaks used for \code{aheatmap}, after adjusting
for quantile.}
}
}
\description{
Make heatmap with color scale from one matrix and hiearchical clustering of
samples/features from another. Also built in functionality for showing the
clusterings with the heatmap. Builds on \code{\link[NMF]{aheatmap}} function
of \code{NMF} package.
}
\details{
The plotHeatmap function calls \code{\link[NMF]{aheatmap}} to draw
  the heatmap. The main points of \code{plotHeatmap} are to 1) allow for
  different matrix inputs, separating out the color scale visualization and
  the clustering of the samples/features. 2) to visualize the clusters and
  meta data with the heatmap. The intended use case is to allow the user to
  visualize the original count scale of the data (on the log-scale), but
  create the hierarchical clustering on another, more appropriate dataset for
  clustering, such as normalized data. Similarly, some of the palettes in the
  package were developed assuming that the visualization might be on
  unscaled/uncentered data, rather than the residual from the mean of the
  gene, and thus palettes need to take on a greater range of relevant values
  so as to show meaningful comparisons with genes on very different scales.

If \code{data} is a \code{ClusterExperiment} object,
  \code{visualizeData} indicates what kind of transformation should be done
  to \code{assay(data)} for calculating the color scale. The features will be
  clustered based on these data as well. A different data.frame or matrix can
  be given for the visualization. For example, if the
  \code{ClusterExperiment} object contains normalized data, but the user
  wishes that the color scale be based on the log-counts for easier
  interpretation, \code{visualizeData} could be set to be the
  \code{log2(counts + 1)}.

If \code{data} is a \code{ClusterExperiment} object,
  \code{clusterSamplesData} can be used to indicate the type of clustering
  for the samples. If equal to `dendrogramValue` the dendrogram stored in
  \code{data} will be used; if missing, a new one will be created based on
  the \code{primaryCluster} of data. If equal to "hclust", then standard
  hierachical clustering of the transformed data will be used. If
  'orderSamplesValue' no clustering of the samples will be done, and instead
  the samples will be ordered as in the slot \code{orderSamples} of
  \code{data}. If equal to 'primaryCluster', again no clustering will be
  done, and instead the samples will be ordered based on grouping the samples
  to match the primaryCluster of \code{data}. If not one of these values,
  \code{clusterSamplesData} can be a character vector matching the
  clusterLabels (colnames of clusterMatrix).

If \code{data} is a matrix, then \code{sampleData} is a data.frame
  of annotation data to be plotted above the heatmap and
  \code{whSampleDataCont} gives the index of the column(s) of this dataset
  that should be consider continuous. Otherwise the annotation data for
  \code{sampleData} will be forced into a factor (which will be nonsensical
  for continous data). If \code{data} is a \code{ClusterExperiment} object,
  \code{sampleData} should refer to a index or column name of the
  \code{colData} slot of \code{data}. In this case \code{sampleData} will be
  added to any choices of clusterings chosen by the \code{whichClusters}
  argument (if any). If both clusterings and sample data are chosen, the
  clusterings will be shown closest to data (i.e. on bottom).

If \code{data} is a \code{ClusterExperiment} object,
  \code{clusterFeaturesData} is not a dataset, but instead indicates which
  features should be shown in the heatmap. "var" selects the
  \code{nFeatures} most variable genes (based on
  \code{transformation(assay(data))}); "PCA" results in a heatmap of the top
  \code{nFeatures} PCAs of the \code{transformation(assay(data))}.
  clusterFeaturesData can also be a vector of characters or integers,
  indicating the rownames or indices respectively of \code{assay(data)} that
  should be shown. For all of these options, the features are clustered based
  on the \code{visualizeData} data. Finally, in the \code{ClusterExperiment}
  version of \code{plotHeatmap}, \code{clusterFeaturesData} can be a list of
  indices or rownames, indicating that the features should be grouped
  according to the elements of the list, with blank (white) space between
  them (see \code{\link{makeBlankData}} for more details). In this case, no
  clustering is done of the features.

If \code{breaks} is a numeric value between 0 and 1, then
  \code{breaks} is assumed to indicate the upper quantile (on the log scale)
  at which the heatmap color scale should stop. For example, if
  \code{breaks=0.9}, then the breaks will evenly spaced up until the 0.9
  upper quantile of \code{data}, and then all values after the
  0.9 quantile will be absorbed by the upper-most color bin. This can help to
  reduce the visual impact of a few highly expressed genes (features).

Note that plotHeatmap calls \code{\link[NMF]{aheatmap}} under the
  hood. This allows you to plot multiple heatmaps via
  \code{par(mfrow=c(2,2))}, etc. However, the dendrograms do not resize if
  you change the size of your plot window in an interactive session of R
  (this might be a problem for RStudio if you want to pop it out into a large
  window...).

\code{plotCoClustering} is a convenience function to plot the heatmap
of the co-clustering matrix stored in the \code{coClustering} slot of a
\code{ClusterExperiment} object.
}
\examples{
data(simData)

cl <- rep(1:3,each=100)
cl2 <- cl
changeAssign <- sample(1:length(cl), 80)
cl2[changeAssign] <- sample(cl[changeAssign])
ce <- clusterExperiment(simCount, cl2, transformation=function(x){log2(x+1)})

#simple, minimal, example. Show counts, but cluster on underlying means
plotHeatmap(ce)

#assign cluster colors
colors <- bigPalette[20:23]
names(colors) <- 1:3
plotHeatmap(data=simCount, clusterSamplesData=simData,
sampleData=data.frame(cl), clusterLegend=list(colors))

#show two different clusters
anno <- data.frame(cluster1=cl, cluster2=cl2)
out <- plotHeatmap(simData, sampleData=anno)

#return the values to see format for giving colors to the annotations
out$clusterLegend

#assign colors to the clusters based on plotClusters algorithm
plotHeatmap(simData, sampleData=anno, alignSampleData=TRUE)

#assign colors manually
annoColors <- list(cluster1=c("black", "red", "green"),
cluster2=c("blue","purple","yellow"))

plotHeatmap(simData, sampleData=anno, clusterLegend=annoColors)

#give a continuous valued -- need to indicate columns
anno2 <- cbind(anno, Cont=c(rnorm(100, 0), rnorm(100, 2), rnorm(100, 3)))
plotHeatmap(simData, sampleData=anno2, whSampleDataCont=3)

#compare changing breaks quantile on visual effect
\dontrun{
par(mfrow=c(2,2))
plotHeatmap(simData, colorScale=seqPal1, breaks=1, main="Full length")
plotHeatmap(simData,colorScale=seqPal1, breaks=.99, main="0.99 Quantile Upper
Limit")
plotHeatmap(simData,colorScale=seqPal1, breaks=.95, main="0.95 Quantile Upper
Limit")
plotHeatmap(simData, colorScale=seqPal1, breaks=.90, main="0.90 Quantile
Upper Limit")
}

}
\author{
Elizabeth Purdom
}

